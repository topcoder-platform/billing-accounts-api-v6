generator client {
  provider      = "prisma-client-js"
  // Ensure Alpine uses the OpenSSL 3-compatible binary
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Client {
  id           String   @id @default(uuid())
  name         String
  codeName     String?    @db.VarChar(255) // customer number / internal code
  status       ClientStatus @default(ACTIVE)
  startDate    DateTime?
  endDate      DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  billingAccounts BillingAccount[]

  @@index([name])
  @@index([codeName])
  @@index([status])
  @@index([startDate, endDate])
}

enum ClientStatus {
  ACTIVE
  INACTIVE
}

model BillingAccount {
  id              Int      @id @default(autoincrement())
  projectId       String?
  name            String
  description     String?
  subcontractingEndCustomer String? @db.VarChar(255)
  status          BAStatus   @default(ACTIVE)
  startDate       DateTime?
  endDate         DateTime?
  budget          Decimal     @db.Decimal(20,4)
  markup          Decimal     @db.Decimal(10,4) // 0..1 typical, can exceed 1
  clientId        String
  poNumber        String?     @db.VarChar(255)
  subscriptionNumber String?  @db.VarChar(255)
  isManualPrize   Boolean     @default(false)
  paymentTerms    String?     @db.VarChar(255)
  salesTax        Decimal?    @db.Decimal(10,4)
  billable        Boolean     @default(true)
  createdBy       String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  client          Client      @relation(fields: [clientId], references: [id])
  lockedAmounts   LockedAmount[]
  consumedAmounts ConsumedAmount[]
  accessGrants    BillingAccountAccess[]

  @@index([clientId])
  @@index([status])
  @@index([startDate, endDate])
  @@index([createdBy])
}

enum BAStatus {
  ACTIVE
  INACTIVE
}

model LockedAmount {
  id              String   @id @default(uuid())
  billingAccountId Int
  challengeId     String   // UUID or legacy int-as-string
  amount          Decimal  @db.Decimal(20,4)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  billingAccount  BillingAccount @relation(fields: [billingAccountId], references: [id])

  @@unique([billingAccountId, challengeId], name: "locked_unique_challenge")
  @@index([billingAccountId])
}

model ConsumedAmount {
  id              String   @id @default(uuid())
  billingAccountId Int
  challengeId     String
  amount          Decimal  @db.Decimal(20,4)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  billingAccount  BillingAccount @relation(fields: [billingAccountId], references: [id])

  @@unique([billingAccountId, challengeId], name: "consumed_unique_challenge")
  @@index([billingAccountId])
}

// Optional: whitelist which users can access which BAs for userId filtering
model BillingAccountAccess {
  id              String   @id @default(uuid())
  billingAccountId Int
  userId          String
  createdAt       DateTime @default(now())

  billingAccount  BillingAccount @relation(fields: [billingAccountId], references: [id])

  @@unique([billingAccountId, userId], name: "ba_access_unique")
  @@index([userId])
}
